# 27장. 배열

## 배열이란?
배열은 여러 개의 값을 순차적으로 나열한 자료구조이다.

<hr>

## 자바스크립트 배열은 배열이 아니다.

자료구조에서 말하는 배열은 **밀집 배열(dense array)** 로 배열의 요소는 하나의 데이터 타입으로 통일되어 있다. <br>
자바스크립트의 배열은 배려의 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 이를 **희소배열** 이라고 한다.

=> 자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체이다.

<hr>

## length 프로퍼티와 희소배열
length 프로퍼티는 요소의 개수, 즉 배여릐 길이를 나타내는 0 이상의 정수를 값으로 갖는다. length 프로퍼티의 값은 빈 배열일 경우 0이며, 빈 배열이 아닐 경우 가장 큰 인덱스에 1을 더한 것과 같다.

<hr>

## 배열 생성

1. 배열 리터럴
```javascript
const arr = [1,2,3];
```

2. Array 생성자 함수
```javascript
const arr = new Array(10);
```

3. Array of

ES6에서 도입된 Array.of 메서드는 전달된 인수를 요소로 갖는 배열을 생성한다.
```javascript
// 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.
Array.of(1); // [1]
Array.of(1,2,3) // [1,2,3]
Array.of('string') // ['string']
```

4. Array.from

ES6에서 도입된 Array.from 메서드는 유사 배열 객체(array-like object) 또는 이터러블 객체(iterable object)를 인수로 전달받아 배열로 변환하여 반환한다.
```javascript
// 유사배열 객체를 변환하여 배열을 생성한다.
Array.from({ length: 2, 0: 'a', 1: 'b'}); // ['a', 'b']

// 이터러블을 변환하여 배열을 생성한다. 문자열은 이터러블이다.
Array.from('Hello'); // ['H', 'e', 'l', 'l', 'o']
```

유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체를 말한다. 배열처럼 for문으로 순회할 수도 있다.

```javascript
const arrayLike = {
    '0': 'apple',
    '1': 'banana',
    length: 2
};

for (let i =0; i< arrayLike.length; i++) {
    console.log(arrayLike[i])
}
```

<hr>

## 배열 요소의 참조

배열의 요소를 참조할 때는 대괄호( [ ] ) 표기법을 사용한다. 대괄호 안에는 인덱스가 와야 한다. 정수로 평가되는 표현식이라면 인덱스 대신 사용할 수 있다.

<hr>

## 배열 요소의 추가와 갱신

객체에 프로퍼티를 동적으로 추가할 수 있는 것처럼 배열에도 요소를 동적으로 추가할 수 있다. 존재하지 않는 인덱스를 사용해 값을 할당하면 새로운 요소가 추가된다. 이때 length 프로퍼티 값은 자동을 갱신된다.

```javascript
const arr = [0];

arr[1] = 1;
console.log(arr); // [0, 1]

arr[1] = 2;
console.log(arr); // [0, 2]
```

<hr>

## 배열 요소의 삭제

배열은 사실 객체이기 때문에 배열의 특정 요소를 삭제하기 위해 delete 연산자를 사용할 수 있다.

```javascript
const arr = [1, 2, 3];

delete arr[1];
console.log(arr) // [1, empty, 3]
console.log(arr.length) // 3 =>  length 프로퍼티에 영향을 안준다. 즉, 희소배열이 된다.
```

delete 연산자는 객체의 프로퍼티를 삭제한다. 희소배열을 만들지 않으면서 배열의 특정 요소를 완전히 삭제하려면 Array.prototype.splice 메서드를 사용한다.
```javascript
const arr = [1,2,3]

arr.splice(1,1);

console.log(arr) // [1,3]
console.log(arr.length) // 2
```

<hr>

## 배열 메서드

배열에는 원본 배열(배열 메서드를 호출한 배열, 즉 배열 메서드의 구현체 내부에서 this가 가리키는 객체)을 직접 변경하는 메서드와

원본 배열을 직접 변경하지 않고 새로운 배열을 새엇ㅇ하여 변환하는 메서드가 있다.

```javascript
const arr = [1]

// push 메서드는 원본 배열을 직접 변경한다.
arr.push(2)

// concat 메서드는 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환한다.
const result = arr.concat(3)
console.log(arr) // [1,2]
console.log(result)// [1,2,3]
```

### Array.isArray

전달된 인수가 배열이면 true, 아니면 false를 반환한다.


### Array.prototype.indexOf

원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환한다.
```javascript
const arr = [1,2,2,3];

arr.indexOf(2) // 1
arr.indexOf(2,2) // 2 -> 두번째 인수는 검색을 시작할 인덱스이다. 
```

**배열의 특정 요소가 존재하는지 확인할 때 유용하다.**

indexOf 대신 ES7에서 도입된 Array.prototype.includes 메서드들 사용하면 가독성이 더 좋다.
```javascript
const english = ['a', 'b', 'c']
console.log(english.includes('a')) // true
```

### Array.prototype.push (원본 배열 변경 o)

push 메서드는 인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다.

```javascript
const arr = [1,2];

let result = arr.push(3,4)
console.log(result) // 4
```

**push는 성능면에서 좋지 않다**

```javascript
const arr = [1,2]
arr[arr.length] = 3;

// 이게 push 보다 빠르다
```

push 보다 ES6의 스프레드 문법을 사용하는게 좋다.
```javascript
const arr = [1, 2];

const newArr = [...arr, 3];
console.log(newArr) // [1,2,3]
```

### Array.prototype.pop (원본 배열 변경 o)

pop 메서드는 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. 원래 배열이 빈 배열이면 undefined를 반환한다.

```javascript
const arr = [1, 2];

let result = arr.pop()
console.log(result) // 2
```

### Array.prototype.unshift (원본 배열 변경 o)

unshift 메서드는 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 프로퍼티값을 반환한다.

```javascript
const arr = [1, 2];

let result = arr.unshift(3,4)
console.log(result) // 4
console.log(arr) // 3,4,1,2
```

unshift 보다는 스프레드 문법이 낫다.

```javascript
const arr = [1, 2];

const newArr = [3, ...arr]
console.log(newArr) // [3,1,2]
```

### Array.prototype.shift (원본 배열 변경 o)

shift 메서드는 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undefined를 반환한다.

```javascript
const arr = [1,2]

let result = arr.shift()
console.log(result) // 1
console.log(arr) // [2]
```

### Array.prototype.concat (원본 배열 변경 x)

concat 메서드는 인수로 전달된 값들을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다. 인수로 전달한 값이 배열인 경우 배열을 해체하여 새로운 배열의 요소로 추가한다.

```javascript
const arr1 = [1,2]
const arr2 = [3,4]

let result = arr1.concat(arr2)

console.log(result) // [1,2,3,4]
```

concat 보다 스프레드 문법을 쓰는게 낫다.

```javascript
let result = [...[1,2], ...[3,4]]
console.log(result) // [1,2,3,4]
```

### Array.prototype.splice (원본 배열 변경 o)

splice 메서드는 원본 배열의 중간에 요소를 추가하거나 중간에 있는 요소를 제거한다. 3개의 매개변수가 있다.

```javascript
const arr = [1,2,3] 
// 1: start => 원본 배열의 요소를 제거하기 시작할 인덱스
// 2: deleteCount => start로 부터 제거할 요소의 개수 (옵션)
// 3: items => 제거한 위치에 삽입할 요소들의 목록 (옵션)

const test = [1,2,3,4]

// 원본 배열의 인덱스 1부터 2개 요소를 제거하고 그 자리에 새로운 요소 20,30 삽입
const result = test.splice(1,2,20,30)

// 제거한 요소가 배열로 반환
console.log(result) // [2,3]
// 원본 배열을 직접 변경
console.log(test) // [1,20,30.4]
```

