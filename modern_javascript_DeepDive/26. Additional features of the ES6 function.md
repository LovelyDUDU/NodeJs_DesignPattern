# ES6 함수의 추가 기능

## 함수의 구분

ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. ES6 이전의 모든 함수는 callable 이면서 constructor다.

|||
|----|--------|
|callable|호출할 수 있는 함수 객체|
|constructor|인스턴스를 생성할 수 있는 함수 객체|
|non-constructor|인스턴스를 생성할 수 없는 함수 객체|

|ES6 함수의 구분|constructor|prototype|super|arguments|
|-------------|-----------|---------|-----|---------|
|일반함수|O|O|X|O|
|메서드|X|X|O|O|
|화살표함수|X|X|X|X|

<hr>

## 메서드

ES6 사양에서 메서드는 메서드 축약 표현으로 정의도니 함수만을 의미한다.
```javascript
const obj = {
    x: 1,
    foo() { return this.x; }, // 메서드
    bar: function () { return this.x; } // 일반 함수
};

console.log(obj.foo());
console.log(obj.bar());
```

ES6 사양에서 정의한 메서드는 인스턴스를 생성할 수 없는 non-constructor다.
```javascript
new obj.foo(); // TypeError
new obj.bar(); // bar {}
```

ES6 메서드는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.
```javascript
obj.foo.hasOwnProperty('prototype') // false
obj.bar.hasOwnProperty('prototype') // true
```

ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬룻 [[HomeObject]]를 갖는다 => super 키워드를 사용할 수 있다.

```javascript
const base = {
    name: 'Lee',
    sayHi() {
        return `Hi! ${this.name}`;
    }
};

const derived = {
    __proto__ : base,
    sayHi() {
        return `${super.sayHi()}`
    }
}
```

<hr>

## 화살표 함수

화살표 함수는 함수 선언문으로 정의할 수 없고 함수 표현식으로 정의해야 한다.
```javascript
const multiply = (x,y) => x * y;
multiply(2, 3);
```

객체 리터럴을 반환하는 경우 객체 리터럴을 소괄호 ()로 감싸줘야 한다.
```javascript
const create = (id, content) => ({ id, content });
create(1, 'JavaScript');

const create = (id, content) => { return { id, content }; };
```

즉시 실행 함수로 사용할 수 있따.
```javascript
const person = (name => ({
    sayHi() { return `Hi My name is ${name} `; }
}))('Lee');

console.log(person.sayHi());
```

화살표 함수도 일급객체라서 Array.prototype.map, Array.prototype.filter, Array.prototype.reduec 같은 고차 함수에 인수로 전달할 수 있다.
```javascript
[1,2,3].map(v => v*2);
```

<hr> 

## 화살표 함수와 일반 함수의 차이

- 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor다.
- 중복된 매개변수 이름을 선언할 수 없다.
- 화살표 함수는 함수자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.

<hr>

## this
