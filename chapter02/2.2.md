# Module system and its pattern

<hr>

> ### 모듈의 역할
> - 복잡한 어플리케이션을 구성하기 위한 블록역할
> - exports 표시되지 않은 모든 내부적인 함수와 변수들을 비공개로 유지하여 정보를 숨기는 메커니즘

## 노출식 모듈 패턴

js는 네임스페이스가 없어 전역 범위에서 실행되는 프로그램은 내부 어플리케이션과 종속된 라이브러리 코드의 데이터들로 인해 충돌이 발생할 수 있다.

이 문제를 해결하기 위한 기법이 **노출식 모듈 패턴(revealing module pattern)** 이다.

### 노출식 모듈 패턴

자기 호출 함수를 사용하여 private 범위를 만들고 공개될 부분만 export함+

```javascript
const module = (() => {
    // 여기는 외부에서 접근 x
    const privateFoo = () => {...};
    const privateBar = [];

    const exported = { // 여기 있는 것만 return해서 export 시킴
        publicFoo: () => {...},
        publicBar: () => {...}
    };

    return exported
})();
console.log(module);
```

<hr>

## Node.js 모듈 설명

### 직접 만드는 모듈 로더

```javascript
function loadModule(filename, module, require) {
    const wrappedSrc = `(function(module, exports, require) {
        ${fs.readFileSync(filename, 'utf8')}
    })(module, module.exports, require);`;
    eval(wrappedSrc);
}
```

```javascript
// require() 함수 구현
const require = (moduleName) => {
    console.log(`Require invoked for module: ${moduleName}`);
    const id = require.resolve(moduleName);
    
    if (require.cache[id]) { // 캐싱된 경우 바로 리턴
        return require.cache[id].exports;
    }

    // 모듈 메타데이터a
    const module = { // 최초 로드를 위한 환경 설정. 빈 객체 리터럴을 통해 module 객체 생성
        exports: {},
        id: id
    };

    require.cache[id] = module; // 캐싱

    loadModule(id, module, require);

    return module.exports;
};
require.cache = {};
require.resolve = (moduleName) => {
    // moduleName에서 모듈 ID 확인
};
```

### 모듈 정의

```javascript
// 모듈 정의하는 방법

// 다른 종속성 로드
const dependency = require('./anotherModule');

// private 함수
function log() {
    console.log(`Well done ${dependency.username}`);
}

// export되어 외부에서 사용될 API
module.exports.run = () => {
    log();
}
```

module.exports 변수에 할당되지 않는 한, 모듈 내부의 모든 항목은 private

### 전역 정의

> 전역 범위를 많이 사용하는 것은 모듈 시스템이 갖는 장점을 무효화하는 나쁜 습관임.

### module.exports 대 exports

변수 exports는 module.exports의 초기 값에 대한 참조일 뿐이다.

