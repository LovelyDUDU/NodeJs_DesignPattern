도커로 작업할 때 컨테이너 뿐만 아니라 이미지도 필요하다.

컨테이너는 애플리케이션, 웹사이트, 노드 서버, 애플리케이션 실행 환경등 무엇이든 포함하는 작은 패키지다.

-> 우리가 하는 행위는 Unit of software를 구동하는 것.

도커로 작업할 때 이미지라는 디졸버(dissolver) 개념도 필요하다.

이미지는 실제로 코드와 코드를 실행하는데 필요한 도구를 포함한다.
이미지는 모든 설정 명령과 모든 코드가 포함된 공유 가능한 패키지이다.

컨테이너는 이러한 이미지의 구체적인 실행 인스턴스이다.

이미지와 컨테이너에서 이미지는 블루프린트이고, 템플릿은 코드와 애플리케이션을 포함하며, 컨테이너는 실행 애플리케이션이 된다.

## Images 
모든 설정 명령과 코드가 포함된 공유 가능한 패키지이다. 이미지는 컨테이너에 필요한 모든 논리와 모든 코드를 보관하는데 사용된다.

이미 존재하는 이미지를 사용할 수도 있고, 이미지를 커스터마이징해서 사용할 수도 있다.

`이미지는 컨테이너의 템플릿 이어야 한다. 이미지를 실행하는 것이 아니라, 이미지를 기반으로 컨테이너를 실행해야 한다.`

```bash
# 현재 docker 프로세스 목록 출력
# -a : 도커가 생선한 모든 컨테이너, 프로세스를 표시한다.
docker ps -a
```

```bash
# 이미지의 인스턴스를 만드는 명령어
# -i : 사용자가 입출력 할 수 있는 상태
# -t : 가상 터미널 환경을 에뮬레이션 하겠다.
docker run node

docker run -it node 
```

## Containers
이미지의 실행 인스턴스이다. 

## Pre-Built

## Custom Images
Dockerfile 을 이용하여 이미지를 만들고, 만들어진 이미지로 컨테이너를 만들어야 한다.
```Dockerfile
# FROM <이미지 이름>
FROM node

# 도커 컨테이너의 작업 디렉토리 설정
WORKDIR /app

# 도커에게 로컬에 있는 파일이 이미지에 들어가야 한다고 알린다.
# 첫번째 경로는 컨테이너의 외부(이미지의 외부 경로) => 이미지로 복사되어야 할 파일들이 있는 곳
# . 를 넣으면 도커에게 기본적으로 Dockerfile이 포함된 동일한 폴더임을 알림. (프로젝트의 모든 폴더, 하위 폴더 및 파일을 복사해야한다고 알림)

# 두번째 경로는 복사한 파일을 저장해야 하는 이미지 내부의 경로
# WORKDIR 이 /app 이라서 ./는 /app 를 말함
COPY . ./

# 도커 컨테이너 및 이미지의 작업 디렉토리에서 명령어 실행
RUN npm install

# 컨테이너가 시작될 때 로컬 시스템에 특정 포트를 노출
# 컨테이너에서 해당 포트(80번)을 외부로 개방한 것이라 연거라 docker run -p 3000:80 <image name> 으로 80번 포트랑 로컬 머신의 포트(3000)을 매핑시켜야 한다.
# EXPOSE 80을 제거해도 된다.
# -p 는 publish 
# 3000:
EXPOSE 80

# 이미지가 실행될 때 실행되지 않고, 이미지를 기반으로 생성된 컨테이너가 시작될때 실행된다. RUN 명령어와 구문이 다르다. 
CMD ["node", "sever.js"]
```

커스텀 이미지를 빌드할때는 (이미지를 만들기만 하고 실행은 x)
```bash
# 현재 위치에 Dockerfile이 있는 경우 .
docker build .
```

Docker image를 삭제하려면 그전에 해당 이미지로 만든 컨테이너 인스턴스를 모두 삭제해야한다.
```bash
# remove docker container
docker rm <conatiner name>
```

애플리케이션에 액세스 하려면 로컬포트(3000) 과 내부 도커 컨테이너 노출 포트(80)을 매핑할때
```bash
docker run -p 3000:80 <image>
```

## Creating & Managing Containers