# Section 2

## 강의 내용
도커로 작업할 때 컨테이너 뿐만 아니라 이미지도 필요하다.

컨테이너는 애플리케이션, 웹사이트, 노드 서버, 애플리케이션 실행 환경등 무엇이든 포함하는 작은 패키지다.

-> 우리가 하는 행위는 Unit of software를 구동하는 것.

도커로 작업할 때 이미지라는 디졸버(dissolver) 개념도 필요하다.

이미지는 실제로 코드와 코드를 실행하는데 필요한 도구를 포함한다.
이미지는 모든 설정 명령과 모든 코드가 포함된 공유 가능한 패키지이다.

컨테이너는 이러한 이미지의 구체적인 실행 인스턴스이다.

이미지와 컨테이너에서 이미지는 블루프린트이고, 템플릿은 코드와 애플리케이션을 포함하며, 컨테이너는 실행 애플리케이션이 된다.

### Images 

모든 설정 명령과 코드가 포함된 공유 가능한 패키지이다. 이미지는 컨테이너에 필요한 모든 논리와 모든 코드를 보관하는데 사용된다.

이미 존재하는 이미지를 사용할 수도 있고, 이미지를 커스터마이징해서 사용할 수도 있다.

`
이미지는 컨테이너의 템플릿 이어야 한다. 이미지를 실행하는 것이 아니라, 이미지를 기반으로 컨테이너를 실행해야 한다.
`

```bash
## 현재 docker 프로세스 목록 출력
## -a : 도커가 생선한 모든 컨테이너, 프로세스를 표시한다.
docker ps -a
```

```bash
## 이미지의 인스턴스를 만드는 명령어
## -i : 사용자가 입출력 할 수 있는 상태
## -t : 가상 터미널 환경을 에뮬레이션 하겠다.
docker run node

docker run -it node 
```

### Containers
이미지의 실행 인스턴스이다. 

### Pre-Built

### Custom Images
Dockerfile 을 이용하여 이미지를 만들고, 만들어진 이미지로 컨테이너를 만들어야 한다.
```Dockerfile
## FROM <이미지 이름>
FROM node

## 도커 컨테이너의 작업 디렉토리 설정
WORKDIR /app

## 도커에게 로컬에 있는 파일이 이미지에 들어가야 한다고 알린다.
## 첫번째 경로는 컨테이너의 외부(이미지의 외부 경로) => 이미지로 복사되어야 할 파일들이 있는 곳
## . 를 넣으면 도커에게 기본적으로 Dockerfile이 포함된 동일한 폴더임을 알림. (프로젝트의 모든 폴더, 하위 폴더 및 파일을 복사해야한다고 알림)

## 두번째 경로는 복사한 파일을 저장해야 하는 이미지 내부의 경로
## WORKDIR 이 /app 이라서 ./는 /app 를 말함
COPY . ./

## 도커 컨테이너 및 이미지의 작업 디렉토리에서 명령어 실행
RUN npm install

## 컨테이너가 시작될 때 로컬 시스템에 특정 포트를 노출
## 컨테이너에서 해당 포트(80번)을 외부로 개방한 것이라 연거라 docker run -p 3000:80 <image name> 으로 80번 포트랑 로컬 머신의 포트(3000)을 매핑시켜야 한다.
## EXPOSE 80을 제거해도 된다.
## -p 는 publish 
## 3000:
EXPOSE 80

## 이미지가 실행될 때 실행되지 않고, 이미지를 기반으로 생성된 컨테이너가 시작될때 실행된다. RUN 명령어와 구문이 다르다. 
CMD ["node", "sever.js"]
```

커스텀 이미지를 빌드할때는 (이미지를 만들기만 하고 실행은 x)
```bash
## 현재 위치에 Dockerfile이 있는 경우 .
docker build .
```

Docker image를 삭제하려면 그전에 해당 이미지로 만든 컨테이너 인스턴스를 모두 삭제해야한다.
```bash
## remove docker container
docker rm <conatiner name>
```

애플리케이션에 액세스 하려면 로컬포트(3000) 과 내부 도커 컨테이너 노출 포트(80)을 매핑할때
```bash
docker run -p 3000:80 <image>
```

한번 이미지를 만들어서 컨테이너로 빌드한 후에 소스코드 변경를 하면 변경사항이 반영되지 않는다. 이미지는 한번 생성되면 잠기기 때문에.

그렇기에 소스코드 변경시 이미지를 재빌드(생성)하고, 새로 만들어진 이미지로 컨테이너를 만들어야 수정된 소스코드가 반영된 것을 확인할 수 있다.

### Creating & Managing Containers

<br><hr>

25. 이미지 레이어 이해하기

이미지를 빌드하면 Dockerfile에 있는 명령이 실행되고, 이미지가 닫힌다.
그렇기 떄문에 코드가 변경되어 새 코드를 새 이미지에 복사하려는 경우와 같이, 무언가를 업데이트해야 하는 경우 다시 빌드 해야한다. 

이처럼 이미지를 빌드하거나 이미지를 다시 빌드할 떄, 변경된 부분의 명령과 그 이후의 모든 명령이 reevaluate(재평가) 되는 것을 레이어 기반이라고 한다.

도커는 이미지를 빌드할 떄 마다 모든 명령 결과를 캐싱하기 떄문에 같은 명령어로 빌드를 여러번 할 경우, 동일한 이미지를 다시 빌드할 때 명령을 다시 실행할 필요가 없으면 캐싱된 결과를 사용한다. 모든 명령은 Dockerfile의 레이어를 나타낸다.

이를 레이어 기반 아키텍처라고 한다.

이미지는 이러한 다양한 명령을 기반으로 여러 레이어에서 간단하게 구성된다. 이미지는 읽기 전용이다.
즉 일단 명령이 실행되고, 이미지가 빌드되면 이미지가 잠기고, 이미지를 다시 빌드하지 않는 한 코드를 변경할 수 없다. 이는 기술적으로 새 이미지를 생성한다는 의미이다. 

하나의 레이어가 변경될 때마다 다른 모든 레이어가 다시 빌드된다. `npm install` 의 경우, 도커는 이전과 동일한 결과를 산출할지 여부를 알 수 없기 떄문에 캐싱과 상관없이 하나의 레이어가 변경될 때 마다 매번 다시 실행된다. (다시 실행해야 하는 항목만 다시 빌드하여 다시 실행하지만, `npm install`은 매번 다시 실행한다는 뜻같다.)

대신 기존 순서에서  `npm install` 전에 `package.json` 파일을 `/app` 에 복사한 다음에 `RUN npm install`을 하고 `COPY . /app` 을 하면 단순히 소스코드를 수정한 경우에는 `npm install` 이 다시 실행되지 않는다. (최적화)
-> 소스코드를 복사하기 전에 `npm install` 레이어가 오기 때문이다. 
```docker
FROM node

WORKDIR /app

COPY package.json /app

RUN npm install

COPY . /app # 소스코드만 변경될 경우, 이 앞의 레이어는 다시 실행되지 않는다. 

EXPOSE 80

CMD ["node", "server.js"]
```

## 정리

### 용어정리

* **Dockerfile** : 이미지를 만들기 위한 설정 파일

### Dockerfile 으로 이미지를 빌드할 때
```bash
docker build .
```

### 현재 docker 프로세스 목록 출력
```bash
docker ps -a
```

### Docker 컨테이너 중지
```bash
docker stop <container name>
```

### Docker 컨테이너 삭제
```bash
docker rm <conatiner name>
```

### Docker 컨테이너 포트 매핑
```bash
docker run -p 3000:80 <image>
```